      // this._reverseLocationAsync();
   // you wrote this
    _reverseLocationAsync = async() => {
      let regionName =  await Location.reverseGeocodeAsync({latitude:42.275863,longitude:-83.72695});
      this.setState({testtest:JSON.stringify(regionName)});
    }


        // You wrote this so im not fully sure
    _getLocationAsync = async() => {
      let{ status } = await Permissions.askAsync(Permissions.LOCATION);
      if (status !== 'granted') {
        this.setState({
          locationResult:'Permission to access location was deinied',
        });
      }
  
      let location = await Location.getCurrentPositionAsync({enableHighAccuracy: false});
      console.log("I AM DONE");
      this.setState({locationResult:JSON.stringify(location)});
  
      var initialPosition = {
        latitude: JSON.parse(this.state.locationResult).coords.latitude,
        longitude: JSON.parse(this.state.locationResult).coords.longitude
      }
  
      var initialRegion = {
        latitude: JSON.parse(this.state.locationResult).coords.latitude,
        longitude: JSON.parse(this.state.locationResult).coords.longitude,
        latitudeDelta: 0.005,
        longitudeDelta: 0.005,
      }
  
      this.setState({mapRegion: initialRegion})
      var currentGeohash = [g.encode_int(initialRegion.latitude,initialRegion.longitude,26)];
      var currentGrid = g.neighbors_int(currentGeohash[0],26);
      currentGrid = currentGeohash.concat(currentGrid);
      this.setState({currentGrid},
        this._addListener);
  
      this.map.animateToRegion(initialRegion, 1);
      this.setState({mapRegion: initialRegion});
  
      
  
      //ADDED THIS LISTENER FOR REAL TIME UPDATES
      // this listener listens to the database for updates. I am working towards only making
      // it listen to the data that is relevant for the map right now.
      // listener = db.collection('locations')
      // .where("geohash", "array-contains", await this.state.currentGrid[0])
      // .onSnapshot(snapshot => {
      //   let changes = snapshot.docChanges();
      //   changes.forEach(change => {
      //     // if a new document is added to the listener. We have to create a location and
      //     // add it to the markers dictionary.
      //     if(change.type == 'added'){
      //       let newGrid = {...this.state.geoHashGrid};
      //       if (change.doc.data().geohash[0] in newGrid) {
      //         let newDictionary = {...newGrid[change.doc.data().geohash[0]]}
      //         newDictionary[change.doc.id] = {
      //             coordinate: {
      //               latitude: change.doc.data().latitude,
      //               longitude: change.doc.data().longitude
      //             },
      //             cost: change.doc.data().count,
      //             address: change.doc.id,
      //             geohash: change.doc.data().geohash[0],
      //             upVotes: change.doc.data().upVotes,
      //             downVotes: change.doc.data().downVotes,
      //             borderColor: "transparent",
      //             key: change.doc.id,
      //         }
      //         newGrid[change.doc.data().geohash[0]] = newDictionary
      //         this.setState({geoHashGrid: newGrid})
      //       } else {
      //         let newDictionary = {};
      //         newDictionary[change.doc.id] = {
      //             coordinate: {
      //               latitude: change.doc.data().latitude,
      //               longitude: change.doc.data().longitude
      //             },
      //             cost: change.doc.data().count,
      //             address: change.doc.id,
      //             geohash: change.doc.data().geohash[0],
      //             upVotes: change.doc.data().upVotes,
      //             downVotes: change.doc.data().downVotes,
      //             borderColor: "transparent",
      //             key: change.doc.id,
      //         }
      //         newGrid[change.doc.data().geohash[0]] = newDictionary
      //         this.setState({geoHashGrid: newGrid})
      //       }
      //     } 
      //     // if a document in the listener has been modified, it will just update the data in the
      //     // markers_ dictionary.
      //     else if(change.type == 'modified'){
      //       let newGrid = {...this.state.geoHashGrid};
      //       // this if statement may be redundant
      //       let newDictionary = newGrid[change.doc.data().geohash[0]];
      //       newDictionary[change.doc.id].cost = change.doc.data().count;
      //       newDictionary[change.doc.id].upVotes = change.doc.data().upVotes;
      //       newDictionary[change.doc.id].downVotes = change.doc.data().downVotes;
      //       newGrid[change.doc.data().geohash[0]] = newDictionary;
      //       this.setState({geoHashGrid: newGrid});
      //     }
      //     // if a document in the listener has been removed it will delete the location from
      //     // the markers_ dictionary
      //     else if(change.type == 'removed') {
      //       let newGrid = {...this.state.geoHashGrid};
      //       // this if statement may be redundant
      //       let newDictionary = newGrid[change.data().geoHashGrid[0]];
      //       delete newDictionary[change.doc.id];
      //       newGrid[change.doc.data().geohash[0]] = newDictionary;
      //       this.setState({geoHashGrid: newGrid})
      //     }
      //   })
      // })
  
      // myApiKey = 'AIzaSyBkwazID1O1ryFhdC6mgSR4hJY2-GdVPmE';
      // fetch('https://maps.googleapis.com/maps/api/geocode/json?address=' + this.state.testMarker.coordinate.latitude + ',' + this.state.testMarker.coordinate.longitude + '&key=' + myApiKey)
      //     .then((response) => response.json())
      //     .then((responseJson) => {
      //         this.setState({testString:JSON.parse(JSON.stringify(responseJson)).results[0].formatted_address});
      // })
    };




        componentWillMount() {
      // TODO: The getlocationAsync() and reverselocationAsync() may be unuseful now. Im leaving
      // them in because you wrote them and I want a second opinon
      // this._getLocationAsync();
      this._getDeviceInfoAsync();
    }

          this._getLocationAsync = this._getLocationAsync.bind(this);


// This funcion adds a new ghost marker which will eventually be used
    // to the database and is triggered in longPressMap.
    addNewLocation = async(latitude_, longitude_) => {
      var ghostGeohash = g.encode_int(latitude_,longitude_,26)
      var address_ = null;
      var results = null;
      var coords = null;
      var city = null;
      var street = null;
      var number = null;
      // fetch the address of the place you are passing in the coordinates of.
      myApiKey = 'AIzaSyBkwazID1O1ryFhdC6mgSR4hJY2-GdVPmE';
      fetch('https://maps.googleapis.com/maps/api/geocode/json?address=' + latitude_ + ',' + longitude_ + '&key=' + myApiKey)
          .then((response) => response.json())
          .then((responseJson) => {
            var len = JSON.parse(JSON.stringify(responseJson)).results.length
            var i = 0;
            var minDist = -1;
            // this loop checks to see which of the possible results returned from the
            // fetch is closest to the latitude and longitude click that are actually passed
            // in. This used to just take the first result, however, sometimes it is not sorted
            // in a fashion of closest so this was causing problems particularly when adding
            // markers to building with multiple sub buildings attached. For example mason,
            // Angel, or Tisch halls.
            for (indx = 0; indx < len; indx++) {
              var dist = math.sqrt(math.square(latitude_-JSON.parse(JSON.stringify(responseJson)).results[indx].geometry.location.lat)+math.square(longitude_-JSON.parse(JSON.stringify(responseJson)).results[indx].geometry.location.lng));
              if (minDist == -1) {
                minDist = dist;
              }
              else if (dist < minDist) {
                minDist = dist;
                i = indx;
              }
            }
            // saves the data of the json result that is closest to the latitude and longitude 
            // passed into the funciton.
            results = JSON.parse(JSON.stringify(responseJson)).results[i]
            address_ = results.formatted_address;
            coords = results.geometry.location;
            len = results.address_components.length;
            var l = null;
            for (j = 0; j < len; j++) {
              l = results.address_components[j].types.length;
              for (k = 0; k < l; k++) {
                if (results.address_components[j].types[k] == "locality") {
                  city = results.address_components[j].long_name;
                }
                if (results.address_components[j].types[k] == "route") {
                  street = results.address_components[j].short_name;
                }
                if (results.address_components[j].types[k] == "street_number") {
                  number = results.address_components[j].long_name;
                }
              }
            }
            // console.log(city);
            // console.log(JSON.parse(JSON.stringify(responseJson)).results[i]);
            // checks to see if the users last known location is close enough to the hub to vote
            // on it
            if ((coords.lat < this.state.userLocation.latitude + 0.02694933525
              && coords.lat > this.state.userLocation.latitude - 0.02694933525
              && coords.lng < this.state.userLocation.longitude + 0.0000748596382
              && coords.lng > this.state.userLocation.longitude - 0.0000748596382)
              || (address_ == this.state.userLocation.address)) {
              // console.log(true);
            } else {
              // console.log(false);
            }
  
            // checks to make sure that the new location is not already part of the markers
            // dictionary. This would mean that the marker is already in the database. May need 
            // to query the actual database though instead... Look into this.
            if (this.state.geoHashGrid[ghostGeohash] == undefined || !Object.keys(this.state.geoHashGrid[ghostGeohash]).includes(address_)) {
              // creates the new ghost marker with the information of this location.
              // console.log('here')
              let newGhostMarker = [];
              newGhostMarker.push({
                  coordinate: {
                    latitude: coords.lat,
                    longitude: coords.lng
                  },
                  city: city,
                  street: street,
                  number: number,
                  key: Math.random()                    
                });
                // console.log(newGhostMarker[0])
                this.setState({showVotingButtons: true})
              // Opens the voting tab for the user.  
              Animated.timing(this.state.animatedTab, {
                toValue: 370,
                friction: 200,
                duration: 500
              }).start();
              this.setState(previousState => (
                { tabVal: !previousState.tabVal 
                }
              ))
              this.setState({selectedMarker: address_});
              this.setState({selectedGeohash: ghostGeohash});
              this.setState({ghostMarker: newGhostMarker});
            }
          })
      }



          toggleTab(markerAddress,geohash) {
      // Checks to see if the marker is in the array of active markers. This is a trigger
      // to see if youre working with a ghost marker. If the marker is a ghost marker
      // and you click it again, it will just hide the tab without adding a new marker 
      // the array.
      // Markers overhaul
      // this.state.geoHashGrid[geohash][markerAddress].borderColor = "#e8b923"
      if(!Object.keys(this.state.geoHashGrid[geohash]).includes(markerAddress)) {
        this.hideTab();
      }
      // checks to see if the marker you clicked on is the one currently stored as
      // selectedMarker. If not, this should change the selected address to the one
      // youre clickig on now.
      else if(this.state.selectedMarker !== markerAddress) {
        // Markers overhaul
        // console.log(this.state.geoHashGrid[geohash][markerAddress].latitude)
        // console.log(this.state.userLocation.userAddressDictionary)
        // if ((this.state.geoHashGrid[geohash][markerAddress].latitude < this.state.userLocation.latitude + 0.05694933525
        //       && this.state.geoHashGrid[geohash][markerAddress].latitude > this.state.userLocation.latitude - 0.05694933525
        //       && this.state.geoHashGrid[geohash][markerAddress].latitude < this.state.userLocation.longitude + 0.0100748596382
        //       && this.state.geoHashGrid[geohash][markerAddress].latitude > this.state.userLocation.longitude - 0.0100748596382)
        //       || (markerAddress == this.state.userLocation.address)) {
        //   console.log(true);
        // } else {
        //   console.log(false);
        // }
  
        if(markerAddress in this.state.userLocation.userAddressDictionary) {
          console.log("YES")
          this.setState({showVotingButtons: true})
        } else {
          console.log("NO")
          this.setState({showVotingButtons: true})
        }
        // Markers overhaul
        // if (this.state.geoHashGrid[geohash][this.state.selectedMarker]) {
        //   this.state.geoHashGrid[geohash][this.state.selectedMarker].borderColor = "transparent"
        // }
  
        if (!this.state.tabVal) {
          Animated.timing(this.state.animatedTab, {
            toValue: 370,
            friction: 100,
            duration: 200
          }).start();
          this.setState(previousState => (
            { tabVal: !previousState.tabVal 
            }
          ))
        }
        this.setState({selectedGeohash: geohash});
        this.setState({selectedMarker: markerAddress});
  
        if (this.state.geoHashGrid[geohash][this.state.selectedMarker]) {
          this.state.geoHashGrid[geohash][this.state.selectedMarker].borderColor = "transparent"
        }
        this.state.geoHashGrid[geohash][markerAddress].borderColor = "#e8b923"
  
        console.log(this.state.geoHashGrid[geohash][this.state.selectedMarker])
        console.log(this.state.selectedMarker);
        console.log(markerAddress)
        // if (this.state.geoHashGrid[geohash][this.state.selectedMarker]) {
        //   this.state.geoHashGrid[geohash][this.state.selectedMarker].borderColor = "#e8b923"
        // }
  
        this.setState({onLongPress: false});
      } 
      // if the marker you're clicking on is neither a ghost marker, nor a new marker, it must
      // be the same one so we just close it.
      else{
        // Markers overhaul
        this.state.geoHashGrid[geohash][markerAddress].borderColor = "transparent"
        this.hideTab();
      }
      
      
    }


        // You wrote this so im not fully sure
    _getLocationAsync = async() => {
      let{ status } = await Permissions.askAsync(Permissions.LOCATION);
      if (status !== 'granted') {
        this.setState({
          locationResult:'Permission to access location was deinied',
        });
      }
  
      let location = await Location.getCurrentPositionAsync({enableHighAccuracy: false});
      this.setState({locationResult:JSON.stringify(location)});
  
      var initialPosition = {
        latitude: JSON.parse(this.state.locationResult).coords.latitude,
        longitude: JSON.parse(this.state.locationResult).coords.longitude
      }
  
      var initialRegion = {
        latitude: JSON.parse(this.state.locationResult).coords.latitude,
        longitude: JSON.parse(this.state.locationResult).coords.longitude,
        latitudeDelta: 0.005,
        longitudeDelta: 0.005,
      }
  
      this.setState({mapRegion: initialRegion})
      var currentGeohash = [g.encode_int(initialRegion.latitude,initialRegion.longitude,26)];
      var currentGrid = g.neighbors_int(currentGeohash[0],26);
      currentGrid = currentGeohash.concat(currentGrid);
      this.setState({currentGrid},
        this._addListener);
  
      this.map.animateToRegion(initialRegion, 1);
      this.setState({mapRegion: initialRegion});
    };


        // collects info from the map in "info" then reads it into addNewLocation.
    onLongPressMap = info => {
      if (!this.state.selectedMarker) {
        let data = info.nativeEvent.coordinate
        // console.log(data)
        // console.log(this.state.userLocation)
        let dist = math.sqrt(math.square(data.latitude - this.state.userLocation.latitude)+math.square(data.longitude - this.state.userLocation.longitude));
        if (dist < 0.0003) {
          this.addNewLocation(data.latitude, data.longitude); 
        }
      }
    }



              {/* <MapView
            // create the map with the map settings
            ref={ref => { this.map = ref; } }  
            minZoomLevel = {16.5}
            maxZoomLevel = {19}
            showsMyLocationButton = {true}          
            zoomEnabled = {true}
            provider = {PROVIDER_GOOGLE}
            showsUserLocation = {true}
            onLongPress = {this.onLongPressMap}
            onPress = {this.toggleTabMapPress}
            onRegionChangeComplete = {this.onRegionChangeComplete}
            // onUserLocationChange = {this.onUserLocationChange}
            style={styles.container}
            initialRegion = {{
              latitude:37.7884459,
              longitude:-122.4066252,
              latitudeDelta: 0.01,
              longitudeDelta: 0.01,
            }}
          > 
            {Object.values(this.state.geoHashGrid).map(markerSet => {
              return(
                Object.values(markerSet).map( (marker) => {
                // creates each marker in the primary markers_ dictionary.
                  return (
                    <MapView.Marker 
                    {...marker} 
                    // on press should toggle the voter tab
                    onPress = {() => this.toggleTab(marker.address,marker.geohash)} 
                    >
                      <View style={{...styles.marker,borderColor:marker.borderColor}} >
                        {this.renderImage(marker.cost)}
                        <Text style={styles.testtext}>{marker.cost}</Text>
                      </View>
      
                    </MapView.Marker>
                  )
                })
              )
            })}
            {this.state.ghostMarker.map( (marker) => {
              // creates the ghostMarker if needed.
              return (
                <MapView.Marker 
                {...marker} 
                // on press should toggle the voter tab. This should only be relevant if pressing
                // to close the tab
                onPress =  {() => this.toggleTab(marker.address)} 
                >
                  <View style={styles.ghostMarker} >
                    <Image
                      style = {{height: 40,
                        resizeMode: 'contain',
                        width: 40,
                        borderRadius: 20,
                        borderWidth: 2,
                        borderColor: 'black',
                        backgroundColor:'white'}}
                      source={require('./assets/poo2.png')}
                    />
                    <Text style={styles.testtext}>?</Text>
                  </View>
  
                </MapView.Marker>
              )
            })}
  
            </MapView> */}




               // toggleTab(markerAddress,geohash) {
    //     // Checks to see if the marker is in the array of active markers. This is a trigger
    //     // to see if youre working with a ghost marker. If the marker is a ghost marker
    //     // and you click it again, it will just hide the tab without adding a new marker 
    //     // the array.
    //     // Markers overhaul
    //     // this.state.geoHashGrid[geohash][markerAddress].borderColor = "#e8b923"
    //     if(!Object.keys(this.props.geoHashGrid[geohash]).includes(markerAddress)) {
    //       this.props.hideTab();
    //     }
    //     // checks to see if the marker you clicked on is the one currently stored as
    //     // selectedMarker. If not, this should change the selected address to the one
    //     // youre clickig on now.
    //     else if(this.props.selectedMarker !== markerAddress) {
    //       // Markers overhaul
    //       // console.log(this.state.geoHashGrid[geohash][markerAddress].latitude)
    //       // console.log(this.state.userLocation.userAddressDictionary)
    //       // if ((this.state.geoHashGrid[geohash][markerAddress].latitude < this.state.userLocation.latitude + 0.05694933525
    //       //       && this.state.geoHashGrid[geohash][markerAddress].latitude > this.state.userLocation.latitude - 0.05694933525
    //       //       && this.state.geoHashGrid[geohash][markerAddress].latitude < this.state.userLocation.longitude + 0.0100748596382
    //       //       && this.state.geoHashGrid[geohash][markerAddress].latitude > this.state.userLocation.longitude - 0.0100748596382)
    //       //       || (markerAddress == this.state.userLocation.address)) {
    //       //   console.log(true);
    //       // } else {
    //       //   console.log(false);
    //       // }
    
    //       if(markerAddress in this.props.userLocation.userAddressDictionary) {
    //         console.log("YES")
    //         this.props.showVotingButtonsHandler(true)
    //         // this.setState({showVotingButtons: true})
    //       } else {
    //         console.log("NO")
    //         this.props.showVotingButtonsHandler(true)
    //         // this.setState({showVotingButtons: true})
    //       }
    //       // Markers overhaul
    //       // if (this.state.geoHashGrid[geohash][this.state.selectedMarker]) {
    //       //   this.state.geoHashGrid[geohash][this.state.selectedMarker].borderColor = "transparent"
    //       // }
    
    //       if (!this.props.tabVal) {
    //         // Animated.timing(this.props.animatedTab, {
    //         //   toValue: 370,
    //         //   friction: 100,
    //         //   duration: 200
    //         // }).start();
    //         // this.setState(previousState => (
    //         //   { tabVal: !previousState.tabVal 
    //         //   }
    //         // ))
    //         this.props.tabValHandler()
    //       }

    //       this.props.selectedGeohashHandler(geohash)
    //     //   this.setState({selectedGeohash: geohash});
    //       this.props.selectedMarkerHandler(markerAddress)
    //     //   this.setState({selectedMarker: markerAddress});
    
    //       if (this.props.geoHashGrid[geohash][this.props.selectedMarker]) {
    //         this.props.geoHashGrid[geohash][this.props.selectedMarker].borderColor = "transparent"
    //       }
    //       this.props.geoHashGrid[geohash][markerAddress].borderColor = "#e8b923"
    
    //       console.log(this.props.geoHashGrid[geohash][this.props.selectedMarker])
    //       console.log(this.props.selectedMarker);
    //       console.log(markerAddress)
    //       // if (this.state.geoHashGrid[geohash][this.state.selectedMarker]) {
    //       //   this.state.geoHashGrid[geohash][this.state.selectedMarker].borderColor = "#e8b923"
    //       // }
    
    //     //   this.setState({onLongPress: false});
    //       this.props.onLongPressHandler(false)

    //     } 
    //     // if the marker you're clicking on is neither a ghost marker, nor a new marker, it must
    //     // be the same one so we just close it.
    //     else{
    //       // Markers overhaul
    //       this.props.geoHashGrid[geohash][markerAddress].borderColor = "transparent"
    //     //   this.props.hideTab;
    //      this.props.hideTab()
    //     }
    //   }